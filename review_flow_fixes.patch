diff --git a/spec/workflow/step3_execute.py b/spec/workflow/step3_execute.py
index 9012d0d..4c5980d 100644
--- a/spec/workflow/step3_execute.py
+++ b/spec/workflow/step3_execute.py
@@ -19,6 +19,7 @@ Supports two display modes:
 
 import os
 import re
+import shutil
 import subprocess
 import threading
 import time
@@ -136,7 +137,6 @@ def _cleanup_old_runs(ticket_id: str, keep_count: int = DEFAULT_LOG_RETENTION) -
     # Remove directories beyond retention limit
     for old_dir in run_dirs[keep_count:]:
         try:
-            import shutil
             shutil.rmtree(old_dir)
         except Exception:
             pass  # Ignore cleanup errors
@@ -147,6 +147,69 @@ def _cleanup_old_runs(ticket_id: str, keep_count: int = DEFAULT_LOG_RETENTION) -
 # =============================================================================
 
 
+def _parse_review_status(output: str) -> str:
+    """Parse review status from agent output.
+
+    Extracts the final status marker from review output, looking for
+    **Status**: PASS or **Status**: NEEDS_ATTENTION in the last occurrence.
+
+    This parser is robust to:
+    - Bold markers (**Status** or Status)
+    - Whitespace variations
+    - Case variations (PASS, Pass, pass)
+    - Multiple occurrences (uses last one as final verdict)
+    - PASS appearing in normal text (only counts if after Status: marker)
+
+    Args:
+        output: Review agent output text
+
+    Returns:
+        "PASS" if review passed, "NEEDS_ATTENTION" if issues found,
+        or "NEEDS_ATTENTION" if status cannot be determined (fail-safe)
+
+    Examples:
+        >>> _parse_review_status("**Status**: PASS\\n\\nLooks good!")
+        'PASS'
+        >>> _parse_review_status("Status: NEEDS_ATTENTION\\n\\nIssues found")
+        'NEEDS_ATTENTION'
+        >>> _parse_review_status("Some text with PASS in it\\n**Status**: NEEDS_ATTENTION")
+        'NEEDS_ATTENTION'
+        >>> _parse_review_status("Ambiguous output")
+        'NEEDS_ATTENTION'
+    """
+    if not output or not output.strip():
+        return "NEEDS_ATTENTION"
+
+    # Pattern to match status line with optional bold markers
+    # Matches: **Status**: PASS, Status: PASS, **Status**: NEEDS_ATTENTION, etc.
+    # Case-insensitive for the status keywords
+    pattern = r'\*\*Status\*\*\s*:\s*(PASS|NEEDS_ATTENTION)|Status\s*:\s*(PASS|NEEDS_ATTENTION)'
+
+    matches = list(re.finditer(pattern, output, re.IGNORECASE))
+
+    if not matches:
+        # No explicit status marker found - check for standalone markers as fallback
+        # Only if they appear near the end (last 500 chars) to avoid false positives
+        tail = output[-500:] if len(output) > 500 else output
+
+        # Look for NEEDS_ATTENTION first (more specific)
+        if re.search(r'\bNEEDS_ATTENTION\b', tail, re.IGNORECASE):
+            return "NEEDS_ATTENTION"
+
+        # Then look for PASS (but be more strict - must be on its own line or after punctuation)
+        if re.search(r'(?:^|\n|[.!?]\s+)\*\*PASS\*\*|(?:^|\n|[.!?]\s+)PASS\s*(?:\n|$)', tail, re.IGNORECASE):
+            return "PASS"
+
+        # No clear marker found - default to NEEDS_ATTENTION (fail-safe)
+        return "NEEDS_ATTENTION"
+
+    # Use the last match as the final verdict
+    last_match = matches[-1]
+    status = last_match.group(1) or last_match.group(2)
+
+    return status.upper()
+
+
 def _parse_stat_total_lines(stat_output: str) -> int:
     """Parse total changed lines from git diff --stat output.
 
@@ -371,7 +434,8 @@ def _run_phase_review(
 
     Executes the spec-reviewer agent to validate completed work.
     If issues are found, offers the user the option to attempt
-    automatic fixes using the implementer agent.
+    automatic fixes using the implementer agent, and optionally
+    re-run the review after fixes.
 
     Args:
         state: Current workflow state
@@ -380,7 +444,7 @@ def _run_phase_review(
 
     Returns:
         True if review passed or user chose to continue,
-        False if user declined to continue after failed review
+        False if user explicitly chose to stop after failed review
     """
     print_step(f"Running {phase} phase review...")
 
@@ -403,26 +467,69 @@ def _run_phase_review(
             dont_save_session=True,
         )
     except Exception as e:
-        print_error(f"Review failed to execute: {e}")
-        return True  # Continue workflow on review failure
+        print_warning(f"Review execution failed: {e}")
+        print_info("Continuing workflow despite review failure")
+        return True  # Continue workflow on review crash (advisory behavior)
 
-    # Parse review result
-    # Check for explicit PASS or NEEDS_ATTENTION markers
-    passed = "PASS" in output and "NEEDS_ATTENTION" not in output
+    # Parse review result using robust parser
+    status = _parse_review_status(output)
 
-    if passed:
+    if status == "PASS":
         print_success(f"{phase.capitalize()} review: PASS")
         return True
 
+    # Review found issues
     print_warning(f"{phase.capitalize()} review: NEEDS_ATTENTION")
 
     # Offer auto-fix
     if prompt_confirm("Would you like to attempt auto-fix?", default=False):
-        _run_auto_fix(state, output, log_dir)
-        print_info("Auto-fix complete. Please review changes manually.")
-        return True  # Continue workflow after fix attempt
+        fix_success = _run_auto_fix(state, output, log_dir)
+
+        if fix_success:
+            # Offer to re-run review after auto-fix
+            if prompt_confirm("Run review again after auto-fix?", default=True):
+                print_step(f"Re-running {phase} phase review after auto-fix...")
 
-    return True  # Continue workflow even if user declined fix
+                # Get updated diff
+                diff_output_retry, is_truncated_retry = _get_smart_diff()
+
+                if not diff_output_retry.strip():
+                    print_info("No changes to review after auto-fix")
+                    return True
+
+                # Build new prompt
+                prompt_retry = _build_review_prompt(state, phase, diff_output_retry, is_truncated_retry)
+
+                # Re-run review
+                try:
+                    success_retry, output_retry = auggie_client.run_print_with_output(
+                        prompt_retry,
+                        agent=state.subagent_names["reviewer"],
+                        dont_save_session=True,
+                    )
+
+                    status_retry = _parse_review_status(output_retry)
+
+                    if status_retry == "PASS":
+                        print_success(f"{phase.capitalize()} review after auto-fix: PASS")
+                        return True
+                    else:
+                        print_warning(f"{phase.capitalize()} review after auto-fix: NEEDS_ATTENTION")
+                        print_info("Issues remain after auto-fix. Please review manually.")
+                        # Fall through to continue prompt below
+
+                except Exception as e:
+                    print_warning(f"Re-review execution failed: {e}")
+                    # Fall through to continue prompt below
+        else:
+            print_warning("Auto-fix reported issues")
+
+    # Ask user if they want to continue or stop
+    if prompt_confirm("Continue workflow despite review issues?", default=True):
+        return True
+    else:
+        print_info("Workflow stopped by user after review")
+        return False
 
 
 def step_3_execute(
@@ -522,9 +629,9 @@ def step_3_execute(
     if pending_fundamental and state.enable_phase_review and not failed_tasks:
         review_passed = _run_phase_review(state, log_dir, phase="fundamental")
         if not review_passed:
-            if not prompt_confirm("Review found issues. Continue to Phase 2?", default=True):
-                print_info("Stopping after Phase 1 review.")
-                return False
+            # User explicitly chose to stop
+            print_info("Stopping after Phase 1 review.")
+            return False
 
     # PHASE 2: Execute independent tasks in parallel
     if pending_independent and state.parallel_execution_enabled:
@@ -582,7 +689,9 @@ def step_3_execute(
     if state.enable_phase_review:
         review_passed = _run_phase_review(state, log_dir, phase="final")
         if not review_passed:
-            print_warning("Review found issues. Please address them before committing.")
+            # User explicitly chose to stop
+            print_warning("Workflow stopped after final review. Please address issues before committing.")
+            return False
 
     _offer_commit_instructions(state)
     print_info(f"Task logs saved to: {log_dir}")
